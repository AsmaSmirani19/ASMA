11  func getAgentsFromDB(db *sql.DB) ([]Agent, error) {
	rows, err := db.Query(`SELECT id, "Name", "Address", "Test_health", "Availability" FROM "Agent_List"`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var agents []Agent
	for rows.Next() {
		var a Agent
		err := rows.Scan(&a.ID, &a.Name, &a.Address, &a.TestHealth, &a.Availability)
		if err != nil {
			return nil, err
		}

		// Utiliser `a.ID` au lieu de `agents[i].ID` car `a` n‚Äôest pas encore ajout√© √† `agents`
		checks, err := GetHealthChecksByAgentID(db, a.ID)
		if err != nil {
			log.Printf("‚ùå Erreur r√©cup√©ration health checks agent %d: %v", a.ID, err)
		} else {
			a.HealthChecks = checks // Assure-toi que le type est bien []AgentHealthCheck dans la struct Agent
		}

		// Ajouter l‚Äôagent avec ses health checks
		agents = append(agents, a)
	}
	return agents, nil
}
22  // ----- Insert un nouveau health check ----- gestion d'errur 
func InsertHealthCheck(db *sql.DB, hc AgentHealthCheck) error {
	query := `INSERT INTO "agent_health_checks" (agent_id, timestamp, status) VALUES ($1, $2, $3)`
	_, err := db.Exec(query, hc.AgentID, hc.Timestamp, hc.Status)
	return err
}

func GetHealthChecksByAgentID(db *sql.DB, agentID int) ([]AgentHealthCheck, error) {
	query := `SELECT id, agent_id, timestamp, status FROM "agent_health_checks" WHERE agent_id = $1 ORDER BY timestamp DESC`
	rows, err := db.Query(query, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var checks []AgentHealthCheck
	for rows.Next() {
		var hc AgentHealthCheck
		err := rows.Scan(&hc.ID, &hc.AgentID, &hc.Timestamp, &hc.Status)
		if err != nil {
			return nil, err
		}
		checks = append(checks, hc)
	}
	return checks, nil
}

//** hediiii jawha behyyyy 

func CheckAndUpdateAllAgentsHealth(db *sql.DB) error {
    agents, err := getAgentsFromDB(db)
    if err != nil {
        return fmt.Errorf("√©chec r√©cup√©ration agents: %w", err)
    }

    for _, agent := range agents {
        // V√©rification plus stricte de l'adresse
        if strings.TrimSpace(agent.Address) == "" {
            log.Printf("‚ö†Ô∏è Agent ID %d a une adresse vide - marqu√© comme indisponible", agent.ID)
            agent.TestHealth = false
            agent.Availability = 0.0
        } else {
            // V√©rification que l'adresse contient un port
            if !strings.Contains(agent.Address, ":") {
                log.Printf("‚ö†Ô∏è Agent ID %d a une adresse mal format√©e: %s", agent.ID, agent.Address)
                agent.TestHealth = false
                agent.Availability = 0.0
            } else {
                agent.TestHealth = CheckAgentHealthGRPC(agent.Address)
                agent.Availability = 100.0
                if !agent.TestHealth {
                    agent.Availability = 0.0
                }
            }
        }
        if err := updateAgentInDB(db, agent); err != nil {
            log.Printf("‚ùå √âchec mise √† jour agent ID %d: %v", agent.ID, err)
            continue
        }
        log.Printf("‚úÖ Agent ID %d - Sant√©: %t - Adresse: %s", agent.ID, agent.TestHealth, agent.Address)
    }
    
    return nil
}

// Availability*******
func updateAgentAvailability(db *sql.DB, agentID int) (float64, error) {
	now := time.Now()
	oneDayAgo := now.Add(-24 * time.Hour)

	rows, err := db.Query(`
		SELECT status FROM "agent_health_checks" 
		WHERE agent_id = $1 AND timestamp >= $2
	`, agentID, oneDayAgo)
	if err != nil {
		return 0, err
	}
	defer rows.Close()

	var total, success int
	for rows.Next() {
		var status string
		if err := rows.Scan(&status); err != nil {
			return 0, err
		}
		total++
		if status == "OK" {
			success++
		}
	}
	availability := 0.0
	if total > 0 {
		availability = float64(success) / float64(total) * 100
	}

	err = updateAgentInDB(db, Agent{ID: agentID, Availability: int(availability)})
	if err != nil {
		return 0, err
	}

	return availability, nil
}



var db *sql.DB
func runHealthCheckHandler(w http.ResponseWriter, r *http.Request) {
    go func() {
        err := CheckAndUpdateAllAgentsHealth(db)
        if err != nil {
            log.Printf("‚ùå Erreur lors de la v√©rification sant√© manuelle: %v", err)
        } else {
            log.Println("‚úÖ V√©rification sant√© manuelle termin√©e avec succ√®s.")
        }
    }()

    w.WriteHeader(http.StatusOK)
    w.Write([]byte("V√©rification sant√© lanc√©e"))
}

type AgentService struct {
    db *sql.DB
}
func (s *AgentService) CheckAndUpdateAllAgentsHealth() error {
    agents, err := getAgentsFromDB(s.db)
    if err != nil {
        return err
    }
    for _, agent := range agents {
        isHealthy := CheckAgentHealthGRPC(agent.Address)  // test sant√© via gRPC
        // Cr√©e un enregistrement de health check
        hc := AgentHealthCheck{
            AgentID:   agent.ID,
            Timestamp: time.Now(),
            Status:    "KO",
        }
        if isHealthy {
            hc.Status = "OK"
        }
        // Sauvegarde health check en DB
        err := InsertHealthCheck(s.db, hc)
        if err != nil {
            log.Printf("Erreur InsertHealthCheck: %v", err)
        }
        // Mets √† jour disponibilit√© de l‚Äôagent
        _, err = updateAgentAvailability(s.db, agent.ID)
        if err != nil {
            log.Printf("Erreur updateAgentAvailability: %v", err)
        }
    }
    return nil
}

	// ü©∫ 4. Lancement p√©riodique des v√©rifications de sant√© des agents
	agentService := &AgentService{db: db}
	go func() {
		ticker := time.NewTicker(30 * time.Second)
		defer ticker.Stop()

		for {
			log.Println("‚è±Ô∏è V√©rification de sant√© des agents...")
			err := agentService.CheckAndUpdateAllAgentsHealth()
			if err != nil {
				log.Printf("‚ùå Erreur v√©rification sant√© agents : %v", err)
			} else {
				log.Println("‚úÖ Health checks mis √† jour")
			}
			// attend 30s avant prochaine v√©rif
		}
	}()