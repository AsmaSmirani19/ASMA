package agent

import (
	"database/sql"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
	"context"
	"encoding/json"


	_ "github.com/lib/pq"
	"github.com/gorilla/websocket"
)

// R√©ception d'un paquet UDP
func receivePacket(conn *net.UDPConn) ([]byte, error) {
    conn.SetReadDeadline(time.Now().Add(5 * time.Second)) // timeout 2s
    buffer := make([]byte, AppConfig.Network.PacketSize)
    n, _, err := conn.ReadFromUDP(buffer)
    if err != nil {
        if ne, ok := err.(net.Error); ok && ne.Timeout() {
            log.Printf("‚ùå Timeout lecture UDP apr√®s 2 secondes")
            return nil, fmt.Errorf("timeout lecture UDP")
        }
        log.Printf("‚ùå Erreur de r√©ception UDP: %v", err)
        return nil, fmt.Errorf("√©chec de la r√©ception du paquet UDP: %v", err)
    }
	
    if n == 0 {
        log.Printf("‚ùå Paquet re√ßu vide (0 octet)")
        return nil, fmt.Errorf("paquet re√ßu vide (0 octet)")
    }
    if n > len(buffer) {
        log.Printf("‚ùå Paquet trop grand: %d octets", n)
        return nil, fmt.Errorf("paquet trop grand: %d octets", n)
    }
    log.Printf("‚úÖ Paquet UDP re√ßu (%d octets)", n)
    return buffer[:n], nil
}

func StartTest(config TestConfig, ws *websocket.Conn) (*PacketStats, *QoSMetrics, error) {
	log.Printf("üöÄ [Client] Lancement du test ID %d...", config.TestID)

	// √âtape 0 bis : V√©rification des param√®tres
	if config.Duration <= 0 {
		log.Println("‚ùå ERREUR : Dur√©e de test invalide ou manquante.")
		if ws != nil {
			_ = sendTestStatus(ws, config.TestID, "failed")
		}
		return nil, nil, fmt.Errorf("Dur√©e de test invalide : %d ms", config.Duration)
	}

	if config.Profile == nil || config.Profile.SendingInterval <= 0 {
		log.Println("‚ùå ERREUR : Intervalle d'envoi invalide ou config.Profile manquant.")
		if ws != nil {
			_ = sendTestStatus(ws, config.TestID, "failed")
		}
		return nil, nil, fmt.Errorf("Intervalle d'envoi invalide : %d ms", config.Profile.SendingInterval)
	}

	// √âtape 1 : Parsing dur√©e
	log.Printf("Dur√©e brute (ms) : %d", config.Duration)
	duration := time.Duration(config.Duration) * time.Millisecond
	log.Printf("Dur√©e convertie : %v", duration)

	// Initialisation du contexte avec timeout
	ctx, cancel := context.WithTimeout(context.Background(), duration)
	defer cancel()

	// √âtape 2 : Initialisation
	stats := &PacketStats{
		StartTime:      time.Now(),
		TargetAddress:  config.TargetIP,
		TargetPort:     config.TargetPort,
		LatencySamples: make([]int64, 0),
		TestID:         config.TestID,
		TargetID:       config.TargetID, 
	}
	qos := &QoSMetrics{}

	// √âtape 3 : Socket UDP
	localAddr := &net.UDPAddr{
		IP:   net.ParseIP(config.SourceIP),
		Port: config.SourcePort,
	}
	conn, err := net.ListenUDP("udp", localAddr)
	if err != nil {
		return nil, nil, fmt.Errorf("‚ùå Socket UDP erreur (%s:%d) : %v",
			config.SourceIP, config.SourcePort, err)
	}
	defer conn.Close()

	log.Printf("‚úÖ Socket bind√© sur %s:%d", config.SourceIP, config.SourcePort)

	// √âtape 4 : WebSocket statut "In progress"
	if ws != nil {
		if err := sendTestStatus(ws, config.TestID, "In progress"); err != nil {
			log.Printf("‚ùå Erreur statut WebSocket : %v", err)
		}
		_ = ws.WriteMessage(websocket.TextMessage, []byte("üü¢ WS Test commenc√©"))
	}

	// √âtape 5 : Boucle d'envoi
	intervalDuration := time.Duration(config.Profile.SendingInterval)
	log.Printf("Intervalle entre paquets : %v", intervalDuration)

	log.Println("üöÄ D√©but de la boucle d'envoi...")

	for {
		select {
		case <-ctx.Done():
			log.Println("‚è±Ô∏è Dur√©e du test atteinte.")
			goto finDuTest
		default:
			log.Println("üîÑ Envoi paquet UDP...")
			if err := handleSender(stats, qos, conn, ws); err != nil {
				log.Printf("‚ùå Erreur handleSender : %v", err)
				if ws != nil {
					_ = sendTestStatus(ws, config.TestID, "failed")
				}
				return nil, nil, err
			}
			time.Sleep(intervalDuration)
		}
	}

finDuTest:
	// √âtape 6 : Calcul m√©triques
	log.Println("üìä Calcul des m√©triques QoS...")

	if stats.SentPackets > 0 {
		qos.PacketLossPercent = float64(stats.SentPackets-stats.ReceivedPackets) / float64(stats.SentPackets) * 100
	}
	if len(stats.LatencySamples) > 0 {
		var totalLatency int64
		for _, lat := range stats.LatencySamples {
			totalLatency += lat
		}
		qos.AvgLatencyMs = float64(totalLatency) / float64(len(stats.LatencySamples)) / 1e6
	}
	if len(stats.LatencySamples) > 1 {
		var totalJitter int64
		for i := 1; i < len(stats.LatencySamples); i++ {
			totalJitter += abs(stats.LatencySamples[i] - stats.LatencySamples[i-1])
		}
		qos.TotalJitter = totalJitter
		qos.AvgJitterMs = float64(totalJitter) / float64(len(stats.LatencySamples)-1) / 1e6
	}
	if duration.Seconds() >= 1.0 && stats.TotalBytesReceived > 0 {
		qos.AvgThroughputKbps = float64(stats.TotalBytesReceived*8) / duration.Seconds() / 1000
	}

	SetLatestMetrics(qos)
	log.Printf("‚úÖ M√©triques calcul√©es : %+v", qos)

		if ws != nil {
		qosMsg := WsQoSMetrics{
			Type:              "qos_metrics",
			TestID:            config.TestID,
			TargetID:          config.TargetID,
			AvgLatencyMs:      qos.AvgLatencyMs,
			AvgJitterMs:       qos.AvgJitterMs,
			AvgThroughputKbps: qos.AvgThroughputKbps,
			PacketLossPercent: qos.PacketLossPercent,
		}

		data, err := json.Marshal(qosMsg)
		if err != nil {
			log.Printf("‚ùå Erreur JSON WebSocket QoS : %v", err)
		} else if err := ws.WriteMessage(websocket.TextMessage, data); err != nil {
			log.Printf("‚ùå Erreur envoi QoS WebSocket : %v", err)
		} else {
			log.Println("üì§ M√©triques QoS envoy√©es via WebSocket.")
		}
	}


	// √âtape 7 : Envoi Kafka  
	log.Printf("üì§ Envoi Kafka : agent_id(TargetID) = %d", config.TargetID)

	kafkaBrokers := []string{"localhost:9092"}
	kafkaTopic := "test-results"
	result := TestResult1{
		TestID:         config.TestID,
		TargetID:       config.TargetID,
		LatencyMs:      qos.AvgLatencyMs,
		JitterMs:       qos.AvgJitterMs,
		ThroughputKbps: qos.AvgThroughputKbps,
	}
	if err := sendTestResultKafka(kafkaBrokers, kafkaTopic, result); err != nil {
		log.Printf("‚ùå Erreur Kafka : %v", err)
	} else {
		log.Printf("‚úÖ R√©sultat Kafka envoy√© (TestID %d)", config.TestID)
	}

	// √âtape 8 : WebSocket "completed"
	if ws != nil {
		if err := sendTestStatus(ws, config.TestID, "completed"); err != nil {
			log.Printf("‚ùå Erreur WebSocket fin: %v", err)
		}
	}
	log.Println("‚úÖ Test termin√© avec succ√®s.")
	return stats, qos, nil
}


// Fonction utilitaire abs pour int64
func abs(x int64) int64 {
    if x < 0 {
        return -x
    }
    return x
}

// D√©claration d'une variable globale pour stocker les m√©triques
var (
	latestMetrics *QoSMetrics
	metricsMutex  sync.RWMutex
)

// Fonction pour enregistrer les m√©triques les plus r√©centes
func SetLatestMetrics(metrics *QoSMetrics) {
	metricsMutex.Lock()
	defer metricsMutex.Unlock()
	latestMetrics = metrics
	fmt.Println("Les m√©triques ont √©t√© mises √† jour :", latestMetrics)
}

func GetLatestMetrics() *QoSMetrics {
	metricsMutex.RLock()
	defer metricsMutex.RUnlock()
	return latestMetrics
}

// Structure √† envoyer via WebSocket
type WsTestResult struct {
    TestID         int     `json:"test_id"` 
    TargetID       int64   `json:"target_id"`
    ReflectorID    int     `json:"reflector_id"`
    LatencyMs      float64 `json:"latency_ms"`
    JitterMs       float64 `json:"jitter_ms"`
    ThroughputKbps float64 `json:"throughput_kbps"`
}


func handleSender(stats *PacketStats, qos *QoSMetrics, conn *net.UDPConn, wsConn *websocket.Conn) error {
	log.Println("üöÄ handleSender : d√©but")
	
	// ‚úÖ V√©rification que l'adresse cible est bien d√©finie
	if stats.TargetAddress == "" || net.ParseIP(stats.TargetAddress) == nil || stats.TargetPort == 0 {
		log.Printf("‚ùå destination UDP invalide : IP=%q, Port=%d", stats.TargetAddress, stats.TargetPort)
		return fmt.Errorf("destination UDP invalide : IP=%q, Port=%d", stats.TargetAddress, stats.TargetPort)
	}

	// Cr√©ation de l'adresse de destination
	destAddr := &net.UDPAddr{
		IP:   net.ParseIP(stats.TargetAddress),
		Port: stats.TargetPort,
	}
	log.Printf("‚û°Ô∏è Destination UDP: %s:%d", destAddr.IP.String(), destAddr.Port)

	log.Printf("üîµ Socket locale li√©e √†: %s", conn.LocalAddr().String())

	// Incr√©ment du compteur de paquets √† envoyer
	stats.SentPackets++

	// Cr√©ation du paquet TWAMP
	timestamp := uint64(time.Now().UnixNano())
	twampPacket := TwampTestPacket{
		SequenceNumber:        uint32(stats.SentPackets),
		Timestamp:             timestamp,
		ErrorEstimation:       0,
		MBZ:                   0,
		ReceptionTimestamp:    0,
		SenderSequenceNumber:  uint64(stats.SentPackets),
		SenderTimestamp:       timestamp,
		SenderErrorEstimation: 0,
		SenderTTL:             255,
		Padding:               make([]byte, 20),
	}

	serializedPacket, err := SerializeTwampTestPacket(&twampPacket)
	if err != nil {
		log.Printf("‚ùå Erreur de s√©rialisation TWAMP: %v", err)
		return err
	}

	if _, err := conn.WriteToUDP(serializedPacket, destAddr); err != nil {
		log.Printf("‚ùå Erreur d'envoi UDP: %v", err)
		return err
	}
	log.Printf("üì® Attente de r√©ponse UDP sur %s", conn.LocalAddr().String())

	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	receivedData, err := receivePacket(conn)
	if err != nil {
		log.Printf("‚ùå Erreur de r√©ception UDP: %v", err)
		return err
	}
	log.Printf("‚úÖ Paquet re√ßu (%d octets)", len(receivedData))
	stats.TotalBytesReceived += int64(len(receivedData))
	stats.ReceivedPackets++

	var receivedPacket TwampTestPacket
	if err := deserializeTwampTestPacket(receivedData, &receivedPacket); err != nil {
		log.Printf("‚ùå Erreur de d√©s√©rialisation TWAMP: %v", err)
		return err
	}
	receivedPacket.ReceptionTimestamp = uint64(time.Now().UnixNano())

	// Calcul de la latence
	latency := int64(receivedPacket.ReceptionTimestamp - receivedPacket.SenderTimestamp)
	stats.LatencySamples = append(stats.LatencySamples, latency)
	stats.LastLatency = latency

	// Calcul du jitter
	var jitterMs float64
	if len(stats.LatencySamples) > 1 {
		prev := stats.LatencySamples[len(stats.LatencySamples)-2]
		jitter := abs(latency - prev)
		qos.TotalJitter += jitter
		jitterMs = float64(qos.TotalJitter) / float64(len(stats.LatencySamples)-1) / 1e6
	}

	// Calcul du d√©bit
	elapsed := time.Since(stats.StartTime).Seconds()
	var throughputKbps float64
	if elapsed > 0 {
		throughputKbps = float64(stats.TotalBytesReceived*8) / 1000 / elapsed
	}

	latencyMs := float64(latency) / 1e6
	log.Printf("üß™ DEBUG TargetID stats: %d", stats.TargetID)

	// Construction du message WebSocket
		wsResult := WsTestResult{
		TestID:    stats.TestID,
		TargetID: int64(stats.TargetID),
		LatencyMs: latencyMs,
		JitterMs:  jitterMs,
		ThroughputKbps: throughputKbps,
	}

	log.Printf("üìä R√©sultat WebSocket √† envoyer: %+v", wsResult)

	// Envoi WebSocket
	if wsConn != nil {
		log.Printf("üì° Envoi WebSocket actif : TestID=%d", stats.TestID)
		data, err := json.Marshal(wsResult)
		if err != nil {
			log.Printf("‚ùå Erreur JSON WebSocket : %v", err)
		} else if err := wsConn.WriteMessage(websocket.TextMessage, data); err != nil {
			log.Printf("‚ùå Erreur envoi WebSocket : %v", err)
		} else {
			log.Println("üì§ R√©sultat envoy√© via WebSocket.")
		}
	}

	// Affichage console
	fmt.Printf("‚úÖ [Paquet %d] Latence: %.3f ms | Jitter: %.3f ms | D√©bit: %.3f kbps\n",
		stats.SentPackets, latencyMs, jitterMs, throughputKbps)

	return nil
}

func handleReflector(conn *net.UDPConn, addr *net.UDPAddr, data []byte) error {
	log.Println("üü¢ Reflector lanc√©...")
	log.Printf("üü¢ Reflector en √©coute sur %s", conn.LocalAddr().String())

	log.Printf("üõ†Ô∏è handleReflector appel√© pour %s (taille: %d)", addr.String(), len(data))

	// ‚úÖ Log pour v√©rifier r√©ception
	log.Printf("üì• Paquet brut re√ßu de %s (%d octets)", addr.String(), len(data))
	log.Printf("üì¶ Contenu brut (hex) : %x", data)

	var receivedPacket TwampTestPacket
	if err := deserializeTwampTestPacket(data, &receivedPacket); err != nil {
		log.Printf("‚ùå Erreur de d√©s√©rialisation TWAMP : %v", err)
		return fmt.Errorf("erreur de d√©s√©rialisation: %v", err)
	}
	log.Printf("üîç Paquet d√©s√©rialis√© : Sequence #%d, Timestamp=%d", receivedPacket.SequenceNumber, receivedPacket.Timestamp)

	// ‚úÖ Log contenu du paquet re√ßu
	log.Printf("üìä TWAMP re√ßu ‚û§ Seq: %d, SenderTS: %d", receivedPacket.SequenceNumber, receivedPacket.SenderTimestamp)

	// Ajout du timestamp de r√©ception
	receivedPacket.ReceptionTimestamp = uint64(time.Now().UnixNano())

	// ‚úÖ Log sur le timestamp de r√©ception
	log.Printf("‚è±Ô∏è Ajout ReceptionTimestamp: %d", receivedPacket.ReceptionTimestamp)

	serializedPacket, err := SerializeTwampTestPacket(&receivedPacket)
	if err != nil {
		log.Printf("‚ùå Erreur de s√©rialisation TWAMP : %v", err)
		return fmt.Errorf("erreur de s√©rialisation: %v", err)
	}
	// ‚úÖ Log paquet √† renvoyer
	log.Printf("üì§ Paquet TWAMP pr√™t √† renvoyer (%d octets) √† %s", len(serializedPacket), addr.String())

	// Envoi
	if _, err := conn.WriteToUDP(serializedPacket, addr); err != nil {
		log.Printf("‚ùå √âchec envoi UDP : %v", err)
		return fmt.Errorf("√©chec de l'envoi de la r√©ponse: %v", err)
	}
	log.Printf("üì§ R√©ponse envoy√©e √† %s (%d octets)", addr.String(), len(serializedPacket))

	// ‚úÖ Log final succ√®s
	log.Printf("‚úÖ R√©ponse envoy√©e √† %s ‚û§ Seq: %d", addr.String(), receivedPacket.SequenceNumber)
	return nil
}

func listenAsReflector(ip string, port int) {
	log.Println("üéß [Reflector] Initialisation du r√©flecteur UDP...")

	addr := net.UDPAddr{
		Port: port,
		IP:   net.ParseIP(ip),
	}

	conn, err := net.ListenUDP("udp", &addr)
	if err != nil {
		log.Fatalf("‚ùå Erreur √©coute UDP: %v", err)
	}
	defer conn.Close()

	buffer := make([]byte, 1500)
	log.Printf("üü¢ Reflector en √©coute sur %s", addr.String())

	for {
		n, remoteAddr, err := conn.ReadFromUDP(buffer)
		if err != nil {
			log.Printf("‚ö†Ô∏è Erreur lecture paquet UDP: %v", err)
			continue
		}
		log.Printf("üì• Reflector a re√ßu un paquet de %s (%d octets)", remoteAddr.String(), n)

		// Copier le buffer pour √©viter les conflits entre goroutines
		dataCopy := make([]byte, n)
		copy(dataCopy, buffer[:n])

		go func(data []byte, addr *net.UDPAddr) {
			if err := handleReflector(conn, addr, data); err != nil {
				log.Printf("‚ùå Erreur handleReflector: %v", err)
			}
		}(dataCopy, remoteAddr)
	}
}


type TestStatusMessage struct {
	Type    string      `json:"type"`
	Payload TestStatus  `json:"payload"`
}


func Start(db *sql.DB) {
	log.Println("üöÄ [Agent] D√©marrage de l'agent TWAMP...")

	// Chargement de la configuration
	LoadConfig("agent/config.yaml")

	go Serveur()
	log.Println("üì° [Agent] Serveur TCP lanc√©.")

	//go listenAsReflector("127.0.0.1", 8081)//7
	go listenAsReflector("127.0.0.1", 8080)//8
	//go listenAsReflector("127.0.0.1", 50051)//10
	//go listenAsReflector("127.0.0.1", 8082)//11
	//go listenAsReflector(AppConfig.Reflector.IP, AppConfig.Reflector.Port)


	//go listenAsReflector()

	// ‚úÖ Lancement du WebSocket Agent (avant testWorker)
	wsConn, err := StartWebSocketAgent()
	if err != nil {
		log.Fatalf("‚ùå Impossible d'√©tablir la connexion WebSocket : %v", err)
	}
	defer wsConn.Close()
	log.Println("üîå [Agent] Connexion WebSocket √©tablie.")

	// ‚úÖ D√©marrage du testWorker (tests TWAMP)
	ctx := context.Background()
	brokers := []string{"localhost:9092"}
	go testWorker(ctx, brokers)

	// Lancement du listener Kafka
	go func() {
		defer log.Println("‚ùå [Agent] Kafka Listener a quitt√©.")
		ListenToTestRequestsFromKafka(db)
	}()
	log.Println("üì® [Agent] √âcoute Kafka lanc√©e.")

	// üõ∞Ô∏è D√©marrage du serveur gRPC Agent
	go func() {
		defer log.Println("‚ùå [Agent] Serveur gRPC arr√™t√©.")
		startAgentServer()
	}()
	log.Println("üõ∞Ô∏è [Agent] Serveur gRPC lanc√©.")

	// Bloquer pour maintenir l‚Äôagent actif
	select {}
}