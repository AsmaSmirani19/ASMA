package agent

import (
	"bytes"
	
	"database/sql"
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"sync"
	"time"


	_ "github.com/lib/pq"

	
	"mon-projet-go/core"
	"github.com/gorilla/websocket"
	

)


func SerializeTwampTestPacket(packet *TwampTestPacket) ([]byte, error) {
	buf := new(bytes.Buffer)

	fields := []interface{}{
		packet.SequenceNumber,
		packet.Timestamp,
		packet.ErrorEstimation,
		packet.MBZ,
		packet.ReceptionTimestamp,
		packet.SenderSequenceNumber,
		packet.SenderTimestamp,
		packet.SenderErrorEstimation,
		packet.SenderTTL,
		packet.Padding,
	}
	for _, field := range fields {
		err := binary.Write(buf, binary.BigEndian, field)
		if err != nil {
			return nil, err
		}
	}
	return buf.Bytes(), nil
}

func deserializeTwampTestPacket(data []byte, pkt *TwampTestPacket) error {
	if len(data) < 49 {
		return fmt.Errorf("paquet trop court: %d octets", len(data))
	}

	buf := bytes.NewReader(data)

	fields := []interface{}{
		&pkt.SequenceNumber,
		&pkt.Timestamp,
		&pkt.ErrorEstimation,
		&pkt.MBZ,
		&pkt.ReceptionTimestamp,
		&pkt.SenderSequenceNumber,
		&pkt.SenderTimestamp,
		&pkt.SenderErrorEstimation,
		&pkt.SenderTTL,
	}

	for _, field := range fields {
		if err := binary.Read(buf, binary.BigEndian, field); err != nil {
			return fmt.Errorf("erreur lecture champ: %w", err)
		}
	}

	// Lire les 20 octets de padding
	pkt.Padding = make([]byte, 20)
	if _, err := buf.Read(pkt.Padding); err != nil {
		return fmt.Errorf("erreur lecture padding: %w", err)
	}

	return nil
}

// Envoi d'un paquet UDP
func SendPacket(packet []byte, addr string, port int) error {
	remoteAddr := &net.UDPAddr{
		IP:   net.ParseIP(addr),
		Port: port,
	}
	conn, err := net.DialUDP("udp", nil, remoteAddr)
	if err != nil {
		return err
	}
	defer conn.Close()

	_, err = conn.Write(packet)
	return err
}

// R√©ception d'un paquet UDP
func receivePacket(conn *net.UDPConn) ([]byte, error) {
	conn.SetReadDeadline(time.Now().Add(2 * time.Second))
	buffer := make([]byte, AppConfig.Network.PacketSize)
	n, _, err := conn.ReadFromUDP(buffer)
	if err != nil {
		return nil, fmt.Errorf("√©chec de la r√©ception du paquet UDP: %v", err)
	}
	if n == 0 {
		return nil, fmt.Errorf("paquet re√ßu vide (0 octet)")
	}
	if n > len(buffer) {
		return nil, fmt.Errorf("paquet trop grand: %d octets", n)
	}
	return buffer[:n], nil
}

func StartTest(db *sql.DB, testID int, ws *websocket.Conn) (*PacketStats, *QoSMetrics, error) {
	log.Printf("üöÄ [Client] Lancement du test ID %d...", testID)

	// √âtape 1 : R√©cup√©ration de la configuration
	log.Println("üì• √âtape 1 : Chargement de la configuration du test...")
	config, err := core.LoadFullTestConfiguration(db, testID)
	if err != nil {
		return nil, nil, fmt.Errorf("‚ùå Impossible de r√©cup√©rer la config du test ID %d : %v", testID, err)
	}
	log.Printf("‚úÖ Configuration charg√©e : %+v", config)

	// √âtape 2 : Marquer le test comme "en attente"
	log.Println("üìå √âtape 2 : Marquage du test comme en attente...")
	if err := core.UpdateTestStatus(db, testID, true, false, false, false); err != nil {
		log.Printf("‚ö†Ô∏è Erreur lors de la mise √† jour du test en attente : %v", err)
	}
	if ws != nil {
		log.Println("üì§ Envoi du statut 'pending' via WebSocket...")
		sendTestStatus(ws, testID, "pending")
	}

	// √âtape 3 : Initialisation
	log.Println("‚öôÔ∏è √âtape 3 : Initialisation des structures de m√©triques...")
	duration := config.Duration
	interval := config.Profile.SendingInterval

	stats := &PacketStats{
		StartTime:      time.Now(),
		TargetAddress:  config.TargetIP,
		TargetPort:     config.TargetPort,
		LatencySamples: make([]int64, 0),
	}
	qos := &QoSMetrics{}

	localAddr := &net.UDPAddr{
		IP:   net.ParseIP(config.SourceIP),
		Port: config.SourcePort,
	}

	// √âtape 4 : Cr√©ation du socket UDP
	log.Println("üîå √âtape 4 : Cr√©ation du socket UDP...")
	conn, err := net.ListenUDP("udp", localAddr)
	if err != nil {
		return nil, nil, fmt.Errorf("‚ùå √âchec de l'ouverture du socket UDP (%s:%d) : %v",
			config.SourceIP, config.SourcePort, err)
	}
	defer conn.Close()
	log.Printf("‚úÖ Socket bind√© sur %s:%d", config.SourceIP, config.SourcePort)

	// √âtape 5 : Ex√©cution du test
	log.Println("üöÄ √âtape 5 : Lancement de la boucle d'envoi des paquets...")
	if ws != nil {
		log.Println("üì§ Envoi du statut 'running' via WebSocket...")
		sendTestStatus(ws, testID, "running")
	}

	testEnd := stats.StartTime.Add(duration)
	for time.Now().Before(testEnd) {
		if err := handleSender(stats, qos, conn, int64(testID)); err != nil {
			log.Printf("‚ùå Erreur dans handleSender : %v", err)
			_ = core.UpdateTestStatus(db, testID, false, true, false ,true )
			if ws != nil {
				sendTestStatus(ws, testID, "failed")
			}
			return nil, nil, err
		}
		time.Sleep(interval)
	}

	// √âtape 6 : Calcul des m√©triques QoS
	log.Println("üìä √âtape 6 : Calcul des m√©triques QoS...")
	if stats.SentPackets > 0 {
		qos.PacketLossPercent = float64(stats.SentPackets-stats.ReceivedPackets) / float64(stats.SentPackets) * 100
	}

	if len(stats.LatencySamples) > 0 {
		var totalLatency int64
		for _, lat := range stats.LatencySamples {
			totalLatency += lat
		}
		qos.AvgLatencyMs = float64(totalLatency) / float64(len(stats.LatencySamples)) / 1e6
	}

	if len(stats.LatencySamples) > 1 {
		var totalJitter int64
		for i := 1; i < len(stats.LatencySamples); i++ {
			totalJitter += abs(stats.LatencySamples[i] - stats.LatencySamples[i-1])
		}
		qos.TotalJitter = totalJitter
		qos.AvgJitterMs = float64(totalJitter) / float64(len(stats.LatencySamples)-1) / 1e6
	}

	if duration.Seconds() >= 1.0 && stats.TotalBytesReceived > 0 {
		qos.AvgThroughputKbps = float64(stats.TotalBytesReceived*8) / duration.Seconds() / 1000
	}

	SetLatestMetrics(qos)
	log.Printf("‚úÖ M√©triques calcul√©es : %+v", qos)

	// √âtape 7 : Marquer le test comme termin√©
	log.Println("üèÅ √âtape 7 : Marquage du test comme termin√©...")
	if err := core.UpdateTestStatus(db, testID, false, false, true ,false); err != nil {
		log.Printf("‚ö†Ô∏è Erreur lors de la mise √† jour du test termin√© : %v", err)
	}
	if ws != nil {
		log.Println("üì§ Envoi du statut 'finished' via WebSocket...")
		sendTestStatus(ws, testID, "finished")
	}

	log.Println("‚úÖ Test termin√© avec succ√®s.")
	return stats, qos, nil
}


// Fonction utilitaire pour calculer la valeur absolue
func abs(x int64) int64 {
	if x < 0 {
		return -x
	}
	return x
}

// D√©claration d'une variable globale pour stocker les m√©triques
var (
	latestMetrics *QoSMetrics
	metricsMutex  sync.RWMutex
)

// Fonction pour enregistrer les m√©triques les plus r√©centes
func SetLatestMetrics(metrics *QoSMetrics) {
	metricsMutex.Lock()
	defer metricsMutex.Unlock()
	latestMetrics = metrics
	fmt.Println("Les m√©triques ont √©t√© mises √† jour :", latestMetrics)
}

func GetLatestMetrics() *QoSMetrics {
	metricsMutex.RLock()
	defer metricsMutex.RUnlock()
	return latestMetrics
}

func handleSender(Stats *PacketStats, qos *QoSMetrics, conn *net.UDPConn, testID int64) error {
	fmt.Println("üöÄ handleSender : d√©but")

	destAddr := &net.UDPAddr{
		IP:   net.ParseIP(Stats.TargetAddress),
		Port: Stats.TargetPort,
	}

	// üèóÔ∏è Cr√©ation du paquet TWAMP
	twampPacket := TwampTestPacket{
		SequenceNumber:        uint32(Stats.SentPackets),
		Timestamp:             uint64(time.Now().UnixNano()),
		ErrorEstimation:       0,
		MBZ:                   0,
		ReceptionTimestamp:    0,
		SenderSequenceNumber:  uint64(Stats.SentPackets),
		SenderTimestamp:       uint64(time.Now().UnixNano()),
		SenderErrorEstimation: 0,
		SenderTTL:             255,
		Padding:               make([]byte, 20),
	}

	// üßµ S√©rialisation
	serializedPacket, err := SerializeTwampTestPacket(&twampPacket)
	if err != nil {
		log.Printf("‚ùå Erreur de s√©rialisation: %v", err)
		return fmt.Errorf("erreur de s√©rialisation du paquet TWAMP: %w", err)
	}
	log.Printf("üì¶ Paquet s√©rialis√© (%d octets), envoi vers %s:%d", len(serializedPacket), destAddr.IP, destAddr.Port)

	// üì§ Envoi du paquet
	_, err = conn.WriteToUDP(serializedPacket, destAddr)
	if err != nil {
		log.Printf("‚ùå Erreur d'envoi: %v", err)
		return fmt.Errorf("erreur d'envoi du paquet TWAMP: %w", err)
	}

	// üì• R√©ception du paquet
	receivedData, err := receivePacket(conn)
	if err != nil {
		log.Printf("‚ùå Erreur de r√©ception: %v", err)
		return fmt.Errorf("r√©ception paquet √©chou√©e: %w", err)
	}
	Stats.TotalBytesReceived += int64(len(receivedData))

	var receivedPacket TwampTestPacket
	err = deserializeTwampTestPacket(receivedData, &receivedPacket)
	if err != nil {
		log.Printf("‚ùå Erreur de d√©s√©rialisation: %v", err)
		return fmt.Errorf("erreur de d√©s√©rialisation du paquet re√ßu: %w", err)
	}

	// üïí Timestamp de r√©ception
	receivedPacket.ReceptionTimestamp = uint64(time.Now().UnixNano())

	// üìä Calculs QoS
	latency := int64(receivedPacket.ReceptionTimestamp - receivedPacket.SenderTimestamp)
	Stats.LatencySamples = append(Stats.LatencySamples, latency)
	Stats.LastLatency = latency

	var jitterMs float64 = 0
	if len(Stats.LatencySamples) > 1 {
		prev := Stats.LatencySamples[len(Stats.LatencySamples)-2]
		jitter := abs(latency - prev)
		qos.TotalJitter += jitter
		jitterMs = float64(qos.TotalJitter) / float64(len(Stats.LatencySamples)-1) / 1e6
	}

	Stats.ReceivedPackets++
	Stats.SentPackets++

	latencyMs := float64(latency) / 1e6

	// üì° Calcul du d√©bit moyen en kbps
	elapsed := time.Since(Stats.StartTime).Seconds()
	throughputKbps := float64(Stats.TotalBytesReceived*8) / 1000 / elapsed

	// üßæ Affichage des m√©triques
	fmt.Printf("‚úÖ [Paquet %d] Latence: %.3f ms | Jitter: %.3f ms | D√©bit: %.3f kbps\n",
		Stats.SentPackets,
		latencyMs,
		jitterMs,
		throughputKbps)

	// üõ¢Ô∏è Sauvegarde des r√©sultats dans la base de donn√©es
	db, err := core.InitDB()
	if err != nil {
		log.Fatalf("‚ùå Impossible de se connecter √† la base : %v", err)
	}
	defer db.Close()

	if err := core.SaveAttemptResult(db, testID, latencyMs, jitterMs, throughputKbps); err != nil {
		log.Printf("‚ùå Erreur insertion BDD: %v", err)
	}

	return nil
}

func handleReflector(conn *net.UDPConn, addr *net.UDPAddr, data []byte) error {
	var receivedPacket TwampTestPacket

	// 1. D√©s√©rialisation du paquet re√ßu
	err := deserializeTwampTestPacket(data, &receivedPacket)
	if err != nil {
		return fmt.Errorf("erreur de d√©s√©rialisation: %v", err)
	}

	// 2. Ajout du timestamp de r√©ception
	receivedPacket.ReceptionTimestamp = uint64(time.Now().UnixNano())

	// ‚úÖ 3. Mise √† jour du SenderTimestamp pour refl√©ter l'instant du renvoi
	receivedPacket.SenderTimestamp = uint64(time.Now().UnixNano())

	// 3. S√©rialisation du paquet modifi√©
	serializedPacket, err := SerializeTwampTestPacket(&receivedPacket)
	if err != nil {
		return fmt.Errorf("erreur de s√©rialisation: %v", err)
	}

	// ‚úÖ R√©ponse avec la m√™me connexion √† l'adresse d'origine
	_, err = conn.WriteToUDP(serializedPacket, addr)
	if err != nil {
		return fmt.Errorf("√©chec de l'envoi de la r√©ponse: %v", err)
	}
	log.Printf("‚úÖ Paquet r√©ponse envoy√© √† %s (%d octets)", addr.String(), len(serializedPacket))
	log.Printf("üéØ Paquet re√ßu: Sequence #%d", receivedPacket.SequenceNumber)
	log.Printf("üì¶ Renvoi du paquet vers %s", addr.String())

	return nil
}

// Fonction qui g√®re l'√©coute sur le port Reflector (UDP)
func listenAsReflector() {
	// Adresse du serveur (Reflector)
	addr := net.UDPAddr{
		Port: AppConfig.Reflector.Port,
		IP:   net.ParseIP(AppConfig.Reflector.IP),
	}

	// Ouverture du socket UDP pour √©couter les paquets
	conn, err := net.ListenUDP("udp", &addr)
	if err != nil {
		log.Fatalf("Erreur √©coute UDP: %v", err)
	}
	defer conn.Close()

	// Tampon pour recevoir les paquets
	buffer := make([]byte, 1500)

	log.Println("Reflector en √©coute sur", addr.String())

	// Boucle pour √©couter les paquets en continu
	for {
		// Lecture d'un paquet depuis la connexion UDP
		n, remoteAddr, err := conn.ReadFromUDP(buffer)
		if err != nil {
			log.Printf("Erreur lecture paquet UDP: %v", err)
			continue // Si erreur, on passe √† l'it√©ration suivante
		}

		log.Printf("Re√ßu %d octets de %s", n, remoteAddr.String())

		// Lancer une goroutine pour g√©rer le paquet re√ßu (envoi de r√©ponse ou traitement)
		go func(conn *net.UDPConn, data []byte, addr *net.UDPAddr) {
			err := handleReflector(conn, addr, data)
			if err != nil {
				log.Printf("Erreur traitement paquet dans handleReflector: %v", err)
			}
		}(conn, buffer[:n], remoteAddr)

	}
}



func Start(db *sql.DB) {

	log.Println("D√©marrage de l'agent TWAMP...")

	LoadConfig("agent/config.yaml")

	// Mode Reflector TWAMP
	go listenAsReflector()

	// Serveur gRPC pour Quick Tests
	//go startGRPCServer()

	// Attente du d√©marrage des services
	time.Sleep(2 * time.Second)

	// WebSocket QoS
	go StartWebSocketAgent()


	// Connexion au backend gRPC (client stream)
	go startClientStream()

	// Blocage principal pour emp√™cher l'arr√™t
	select {}
}
